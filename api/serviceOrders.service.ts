/**
 * Tigerpaw API Method Reference
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 18.2.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { TsiWebAdvancedSearchRequest } from '../model/tsiWebAdvancedSearchRequest';
import { TsiWebAssignedMarketingProfilesResponse } from '../model/tsiWebAssignedMarketingProfilesResponse';
import { TsiWebConvertTimeLogsToLaborItemModel } from '../model/tsiWebConvertTimeLogsToLaborItemModel';
import { TsiWebCreateManagedPrintServiceOrderModel } from '../model/tsiWebCreateManagedPrintServiceOrderModel';
import { TsiWebCreateRecurringServiceOrderScheduleModel } from '../model/tsiWebCreateRecurringServiceOrderScheduleModel';
import { TsiWebCreateRecurringServiceOrderScheduleResponse } from '../model/tsiWebCreateRecurringServiceOrderScheduleResponse';
import { TsiWebCreateServiceOrderItemServicedModel } from '../model/tsiWebCreateServiceOrderItemServicedModel';
import { TsiWebCreateServiceOrderModel } from '../model/tsiWebCreateServiceOrderModel';
import { TsiWebCreateServiceOrderNonStockModel } from '../model/tsiWebCreateServiceOrderNonStockModel';
import { TsiWebCreateServiceOrderPartsUsedModel } from '../model/tsiWebCreateServiceOrderPartsUsedModel';
import { TsiWebCreateServiceOrderTimeLogModel } from '../model/tsiWebCreateServiceOrderTimeLogModel';
import { TsiWebCustomField } from '../model/tsiWebCustomField';
import { TsiWebCustomFieldSearchModel } from '../model/tsiWebCustomFieldSearchModel';
import { TsiWebCustomFieldsResponse } from '../model/tsiWebCustomFieldsResponse';
import { TsiWebDateTimeSearchModel } from '../model/tsiWebDateTimeSearchModel';
import { TsiWebDeleteServiceOrderPartsUsedModel } from '../model/tsiWebDeleteServiceOrderPartsUsedModel';
import { TsiWebExpenseModel } from '../model/tsiWebExpenseModel';
import { TsiWebRecurringServiceOrderSchedule } from '../model/tsiWebRecurringServiceOrderSchedule';
import { TsiWebRecurringServiceOrderSchedulesResponse } from '../model/tsiWebRecurringServiceOrderSchedulesResponse';
import { TsiWebResponse } from '../model/tsiWebResponse';
import { TsiWebSearchServiceOrderResponse } from '../model/tsiWebSearchServiceOrderResponse';
import { TsiWebSearchTimeLogResponse } from '../model/tsiWebSearchTimeLogResponse';
import { TsiWebServiceOrderAssignedTech } from '../model/tsiWebServiceOrderAssignedTech';
import { TsiWebServiceOrderDetail } from '../model/tsiWebServiceOrderDetail';
import { TsiWebServiceOrderExpense } from '../model/tsiWebServiceOrderExpense';
import { TsiWebServiceOrderExpenseSearchResponse } from '../model/tsiWebServiceOrderExpenseSearchResponse';
import { TsiWebServiceOrderExpensesResponse } from '../model/tsiWebServiceOrderExpensesResponse';
import { TsiWebServiceOrderItemServicedResponse } from '../model/tsiWebServiceOrderItemServicedResponse';
import { TsiWebServiceOrderItemsServicedResponse } from '../model/tsiWebServiceOrderItemsServicedResponse';
import { TsiWebServiceOrderNoteModel } from '../model/tsiWebServiceOrderNoteModel';
import { TsiWebServiceOrderNoteResponse } from '../model/tsiWebServiceOrderNoteResponse';
import { TsiWebServiceOrderNotesResponse } from '../model/tsiWebServiceOrderNotesResponse';
import { TsiWebServiceOrderPartUsedResponse } from '../model/tsiWebServiceOrderPartUsedResponse';
import { TsiWebServiceOrderPartsUsedCommentModel } from '../model/tsiWebServiceOrderPartsUsedCommentModel';
import { TsiWebServiceOrderPartsUsedResponse } from '../model/tsiWebServiceOrderPartsUsedResponse';
import { TsiWebServiceOrderQuote } from '../model/tsiWebServiceOrderQuote';
import { TsiWebServiceOrderResolutionResponse } from '../model/tsiWebServiceOrderResolutionResponse';
import { TsiWebServiceOrderResponse } from '../model/tsiWebServiceOrderResponse';
import { TsiWebServiceOrderSubContractorsResponse } from '../model/tsiWebServiceOrderSubContractorsResponse';
import { TsiWebServiceOrderSummary } from '../model/tsiWebServiceOrderSummary';
import { TsiWebServiceOrderSymptomResponse } from '../model/tsiWebServiceOrderSymptomResponse';
import { TsiWebServiceOrderTimeLogResponse } from '../model/tsiWebServiceOrderTimeLogResponse';
import { TsiWebServiceOrderTimeLogsResponse } from '../model/tsiWebServiceOrderTimeLogsResponse';
import { TsiWebTasksResponse } from '../model/tsiWebTasksResponse';
import { TsiWebUpdateExpenseModel } from '../model/tsiWebUpdateExpenseModel';
import { TsiWebUpdateManagedServiceOrderModel } from '../model/tsiWebUpdateManagedServiceOrderModel';
import { TsiWebUpdateServiceOrderItemServicedModel } from '../model/tsiWebUpdateServiceOrderItemServicedModel';
import { TsiWebUpdateServiceOrderModel } from '../model/tsiWebUpdateServiceOrderModel';
import { TsiWebUpdateServiceOrderNonStockPartsUsedModel } from '../model/tsiWebUpdateServiceOrderNonStockPartsUsedModel';
import { TsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel } from '../model/tsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel';
import { TsiWebUpdateServiceOrderPartsUsedModel } from '../model/tsiWebUpdateServiceOrderPartsUsedModel';
import { TsiWebUpdateServiceOrderTimeLogModel } from '../model/tsiWebUpdateServiceOrderTimeLogModel';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ServiceOrdersService {

    protected basePath = 'https://api2.tigerpawsoftware.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
        console.log('api config: ', JSON.stringify(this.configuration));
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Advanced search for service orders.
     * When searching by External Ticket only one External Product may be specified and you must use the entire product name in the Criteria.  &lt;p&gt;Valid SearchType &#x3D; ServiceOrderNumber, Reference, InvoiceNumber, ItemID, AgreementNumber, CustomerPurchaseOrder, ExternalProduct, ExternalTicket, AccountNumber, Status, Type, Profile,Resolution,Symptom, or CustomField (requires CategoryName and CustomFieldName)&lt;/p&gt;&lt;p&gt;Valid MatchType &#x3D; StartsWith (default), EndsWith, Contains, GreaterThan, GreaterThanEqual, Equal, LessThan, LessThanEqual&lt;/p&gt;
     * @param request An AdvancedSearchRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling serviceOrdersAdvancedSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        // todo.. add method to get auth token to section in Configuration
        // todo.. add auth token to header, like:
        // request.AddHeader("Authorization", $"TSI {token}");
        // request.AddHeader("X-TSI-Date", headerDateTime);

        let url = `${this.basePath}/api/serviceorders/search`;

        headers = this.configuration.setAuthHeaders(
            headers,
            "post", // httpMethod
            url,    // uri
            );

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(
            url,
            request, // todo.. verify if request params is required to be part of auth header.. ??
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Converts selected time logs to a new labor item on the service order.
     * Valid labor item types are - \&quot;Default\&quot;, \&quot;Selected\&quot;  &lt;p&gt;Supply an array of time logs ids to convert to a labor item on the service order. [1,2,3]&lt;/p&gt;&lt;p&gt;CanConvertNonBillableTimeLogs - allows non billable time logs to be converted with the billable time logs&lt;/p&gt;&lt;p&gt;CanCombineLogsWithDifferentLaborRatesOrRateBasis - allows time logs with a different labor rate or basis to be combined using the default labor rate for the account.&lt;/p&gt;
     * @param serviceOrderNumber The service order number.
     * @param model The convert time logs to labor item model.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersConvertTimeLogsToLaborItem(serviceOrderNumber: number, model: TsiWebConvertTimeLogsToLaborItemModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebResponse>;
    public serviceOrdersConvertTimeLogsToLaborItem(serviceOrderNumber: number, model: TsiWebConvertTimeLogsToLaborItemModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebResponse>>;
    public serviceOrdersConvertTimeLogsToLaborItem(serviceOrderNumber: number, model: TsiWebConvertTimeLogsToLaborItemModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebResponse>>;
    public serviceOrdersConvertTimeLogsToLaborItem(serviceOrderNumber: number, model: TsiWebConvertTimeLogsToLaborItemModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersConvertTimeLogsToLaborItem.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersConvertTimeLogsToLaborItem.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/timelogs/laboritem`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an expense.
     * The DistanceType field accepts values \&quot;DoNotChangeDistance\&quot;, \&quot;SetByEndOdometer\&quot;, or \&quot;SetByDistance\&quot;.
     * @param serviceOrderNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateExpense(serviceOrderNumber: number, model: TsiWebExpenseModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpensesResponse>;
    public serviceOrdersCreateExpense(serviceOrderNumber: number, model: TsiWebExpenseModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpensesResponse>>;
    public serviceOrdersCreateExpense(serviceOrderNumber: number, model: TsiWebExpenseModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpensesResponse>>;
    public serviceOrdersCreateExpense(serviceOrderNumber: number, model: TsiWebExpenseModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateExpense.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateExpense.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpensesResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/expenses`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a managed print service order based on a device id.
     * Used by managed print providers to create a service order for a metered device
     * @param model The model.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateManagedPrintServiceOrder(model: TsiWebCreateManagedPrintServiceOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResponse>;
    public serviceOrdersCreateManagedPrintServiceOrder(model: TsiWebCreateManagedPrintServiceOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResponse>>;
    public serviceOrdersCreateManagedPrintServiceOrder(model: TsiWebCreateManagedPrintServiceOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResponse>>;
    public serviceOrdersCreateManagedPrintServiceOrder(model: TsiWebCreateManagedPrintServiceOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateManagedPrintServiceOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderResponse>(`${this.basePath}/api/serviceorders/managed/print`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates recurring service orders schedules.
     * The Frequency value must be one of: \&quot;Daily\&quot;, \&quot;Weekly\&quot;, \&quot;Monthly\&quot;, \&quot;Yearly\&quot;.If no Frequency is submitted the default value is \&quot;Daily\&quot;.  &lt;p&gt;The EndType value must be one of: \&quot;None\&quot;, \&quot;EndByDate\&quot;, \&quot;NumberOfOccurences\&quot;. If no EndType is submitted, the default value is \&quot;None\&quot;.&lt;/p&gt;&lt;p&gt;The DayOfMonthType must be one of: \&quot;SpecifiedDay\&quot;, \&quot;LastDayOfTheMonth\&quot;, \&quot;FloatingDate\&quot;.&lt;/p&gt;&lt;p&gt;The DayOfTheWeek must be one of: \&quot;Monday\&quot;,\&quot;Tuesday\&quot;,\&quot;Wednesday\&quot;,\&quot;Thursday\&quot;,\&quot;Friday\&quot;,\&quot;Saturday\&quot;,\&quot;Sunday\&quot;,\&quot;None\&quot;.&lt;/p&gt;&lt;p&gt;The WeekOfTheMonth value must be one of: \&quot;First\&quot;,\&quot;Second\&quot;,\&quot;Third\&quot;,\&quot;Fourth\&quot;,\&quot;Last\&quot;.&lt;/p&gt;&lt;p&gt;The TakenByRepType value must be one of: \&quot;SpecifiedRep\&quot;, \&quot;CurrentUser\&quot;,\&quot;AccountDefaultTech\&quot;, \&quot;AccountPrimaryRep\&quot;.&lt;/p&gt;&lt;p&gt;For XML requests, the ServiceOrderRecievedTime accepts values in form  HH/MM/SS.&lt;/p&gt;
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateRecurringServiceOrderSchedule(model: TsiWebCreateRecurringServiceOrderScheduleModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebCreateRecurringServiceOrderScheduleResponse>;
    public serviceOrdersCreateRecurringServiceOrderSchedule(model: TsiWebCreateRecurringServiceOrderScheduleModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebCreateRecurringServiceOrderScheduleResponse>>;
    public serviceOrdersCreateRecurringServiceOrderSchedule(model: TsiWebCreateRecurringServiceOrderScheduleModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebCreateRecurringServiceOrderScheduleResponse>>;
    public serviceOrdersCreateRecurringServiceOrderSchedule(model: TsiWebCreateRecurringServiceOrderScheduleModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateRecurringServiceOrderSchedule.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebCreateRecurringServiceOrderScheduleResponse>(`${this.basePath}/api/serviceorders/recurringSchedule`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a service order.
     * DateTimeRequested is an optional SplitDateTime type. Json format is \&quot;DateTimeRequested\&quot;:{\&quot;Date\&quot;:\&quot;2018-03-06T00:00:00\&quot;, \&quot;Time\&quot;:\&quot;1900-01-01T14:09:02\&quot;}
     * @param model The create service order model.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrder(model: TsiWebCreateServiceOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResponse>;
    public serviceOrdersCreateServiceOrder(model: TsiWebCreateServiceOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResponse>>;
    public serviceOrdersCreateServiceOrder(model: TsiWebCreateServiceOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResponse>>;
    public serviceOrdersCreateServiceOrder(model: TsiWebCreateServiceOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderResponse>(`${this.basePath}/api/ServiceOrders`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an item serviced.
     * The UpdateContractMetersType must be one of: \&quot;DoNotUpdate\&quot;, \&quot;UpdateByReading\&quot;, or \&quot;UpdateByClicksUsed\&quot;.&lt;br /&gt;&lt;p&gt;The CreateServiceOrderItemServicedType must be one of: \&quot;NewItem\&quot;, \&quot;FromPriceBookItem\&quot;, \&quot;FromCustomerInventoryItem\&quot;, \&quot;FromMSPAsset\&quot;, or \&quot;FromContractItem\&quot;.&lt;/p&gt;
     * @param serviceOrderNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderItemServiced(serviceOrderNumber: number, model: TsiWebCreateServiceOrderItemServicedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderItemServicedResponse>;
    public serviceOrdersCreateServiceOrderItemServiced(serviceOrderNumber: number, model: TsiWebCreateServiceOrderItemServicedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersCreateServiceOrderItemServiced(serviceOrderNumber: number, model: TsiWebCreateServiceOrderItemServicedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersCreateServiceOrderItemServiced(serviceOrderNumber: number, model: TsiWebCreateServiceOrderItemServicedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderItemServiced.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderItemServiced.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderItemServicedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/itemsserviced`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a non stock item for a service order.
     * The Type field accepts values \&quot;Labor\&quot;, \&quot;Material\&quot;, or \&quot;Special\&quot;.
     * @param serviceOrderNumber The service order number.
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderNonStockModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersCreateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderNonStockModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersCreateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderNonStockModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersCreateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderNonStockModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderNonStockPartsUsed.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderNonStockPartsUsed.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderPartsUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/nonstock`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a service order note.
     * 
     * @param serviceOrderNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderNote(serviceOrderNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderNoteResponse>;
    public serviceOrdersCreateServiceOrderNote(serviceOrderNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderNoteResponse>>;
    public serviceOrdersCreateServiceOrderNote(serviceOrderNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderNoteResponse>>;
    public serviceOrdersCreateServiceOrderNote(serviceOrderNumber: number, model: TsiWebServiceOrderNoteModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderNote.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderNote.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderNoteResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/notes`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates the service order parts used item.
     * The Price Book Item is selected by either the PriceBookItemNumber or the ItemId. If both are given PriceBookItemNumber will be used. &lt;br /&gt;&lt;p&gt;The UseBookPricesAndDiscounts field is required; if it is true then Price Levels will be used, if it is false then Sell Price will be used.&lt;/p&gt;
     * @param serviceOrderNumber The service order number.
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderPartsUsedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersCreateServiceOrderPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderPartsUsedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersCreateServiceOrderPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderPartsUsedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersCreateServiceOrderPartsUsed(serviceOrderNumber: number, model: TsiWebCreateServiceOrderPartsUsedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderPartsUsed.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderPartsUsed.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        this.basePath = 'https://api2.tigerpawsoftware.com'; // todo.. temp override until I can figure out how to pass this in correctly!
        let url = `https://api3.tigerpawsoftware.com/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts`;

        headers = this.configuration.setAuthHeaders(
            headers,
            "post", // httpMethod
            url,    // uri
            );

        return this.httpClient.post<TsiWebServiceOrderPartsUsedResponse>(
            url,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a line item comment for the service order,
     * 
     * @param serviceOrderNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderPartsUsedComment(serviceOrderNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartUsedResponse>;
    public serviceOrdersCreateServiceOrderPartsUsedComment(serviceOrderNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersCreateServiceOrderPartsUsedComment(serviceOrderNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersCreateServiceOrderPartsUsedComment(serviceOrderNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderPartsUsedComment.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderPartsUsedComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderPartUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/comments`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a resolution on a service order.
     * 
     * @param serviceOrderNumber 
     * @param resolution 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderResolution(serviceOrderNumber: number, resolution: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResolutionResponse>;
    public serviceOrdersCreateServiceOrderResolution(serviceOrderNumber: number, resolution: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersCreateServiceOrderResolution(serviceOrderNumber: number, resolution: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersCreateServiceOrderResolution(serviceOrderNumber: number, resolution: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderResolution.');
        }
        if (resolution === null || resolution === undefined) {
            throw new Error('Required parameter resolution was null or undefined when calling serviceOrdersCreateServiceOrderResolution.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderResolutionResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/resolutions`,
            resolution,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a symptom on a service order.
     * 
     * @param serviceOrderNumber 
     * @param symptom 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderSymptom(serviceOrderNumber: number, symptom: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderSymptomResponse>;
    public serviceOrdersCreateServiceOrderSymptom(serviceOrderNumber: number, symptom: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersCreateServiceOrderSymptom(serviceOrderNumber: number, symptom: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersCreateServiceOrderSymptom(serviceOrderNumber: number, symptom: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderSymptom.');
        }
        if (symptom === null || symptom === undefined) {
            throw new Error('Required parameter symptom was null or undefined when calling serviceOrdersCreateServiceOrderSymptom.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderSymptomResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/symptoms`,
            symptom,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a service order time log.
     * Valid billing option types are - \&quot;InvoiceCustomer\&quot;, \&quot;ApplyToContract\&quot;, \&quot;ApplyToContractAndBillcustomer\&quot;, \&quot;DoNotInvoice\&quot;,   &lt;P&gt;  Valid rate basis values are - \&quot;Regular\&quot;, \&quot;Overtime\&quot;, \&quot;Premium\&quot;, \&quot;Standard\&quot;, \&quot;AccountDefault\&quot;, \&quot;PriceBook\&quot;, \&quot;FlatFee\&quot;, \&quot;Manual\&quot;.The default value will be regular.  &lt;/P&gt;&lt;P&gt;  Valid copy indicator type values are - \&quot;DoNotCopy,\&quot;CopyWhenSaving,\&quot;CopyWhenClosingLog\&quot;.  &lt;/P&gt;&lt;P&gt;  Valid time to invoice type values are - \&quot;BillableHoursMinutes\&quot;, \&quot;UtilizedTime\&quot;, \&quot;RoundedMinimumUtilizedtime\&quot;, \&quot;ActualTime\&quot;, \&quot;RoundedMinimumActualTime\&quot;. The default value for this would be BillableHoursMinutes  &lt;/P&gt;
     * @param serviceOrderNumber Service order number
     * @param model The create service order time log model.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersCreateServiceOrderTimeLog(serviceOrderNumber: number, model: TsiWebCreateServiceOrderTimeLogModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderTimeLogResponse>;
    public serviceOrdersCreateServiceOrderTimeLog(serviceOrderNumber: number, model: TsiWebCreateServiceOrderTimeLogModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderTimeLogResponse>>;
    public serviceOrdersCreateServiceOrderTimeLog(serviceOrderNumber: number, model: TsiWebCreateServiceOrderTimeLogModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderTimeLogResponse>>;
    public serviceOrdersCreateServiceOrderTimeLog(serviceOrderNumber: number, model: TsiWebCreateServiceOrderTimeLogModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersCreateServiceOrderTimeLog.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersCreateServiceOrderTimeLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderTimeLogResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/timelogs`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a part used on a service order.
     * 
     * @param serviceOrderNumber 
     * @param partsUsedNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersDeleteServiceOrderPartsUsed(serviceOrderNumber: number, partsUsedNumber: number, model: TsiWebDeleteServiceOrderPartsUsedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersDeleteServiceOrderPartsUsed(serviceOrderNumber: number, partsUsedNumber: number, model: TsiWebDeleteServiceOrderPartsUsedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersDeleteServiceOrderPartsUsed(serviceOrderNumber: number, partsUsedNumber: number, model: TsiWebDeleteServiceOrderPartsUsedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersDeleteServiceOrderPartsUsed(serviceOrderNumber: number, partsUsedNumber: number, model: TsiWebDeleteServiceOrderPartsUsedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersDeleteServiceOrderPartsUsed.');
        }
        if (partsUsedNumber === null || partsUsedNumber === undefined) {
            throw new Error('Required parameter partsUsedNumber was null or undefined when calling serviceOrdersDeleteServiceOrderPartsUsed.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersDeleteServiceOrderPartsUsed.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.delete<TsiWebServiceOrderPartsUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/${encodeURIComponent(String(partsUsedNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a profile from the service order.
     * The profile must be url encoded
     * @param serviceOrderNumber The service order number.
     * @param id The profile to remove. (Must be url encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersDeleteServiceOrderProfile(serviceOrderNumber: number, id: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebResponse>;
    public serviceOrdersDeleteServiceOrderProfile(serviceOrderNumber: number, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebResponse>>;
    public serviceOrdersDeleteServiceOrderProfile(serviceOrderNumber: number, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebResponse>>;
    public serviceOrdersDeleteServiceOrderProfile(serviceOrderNumber: number, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersDeleteServiceOrderProfile.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling serviceOrdersDeleteServiceOrderProfile.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<TsiWebResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/profiles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a resolution on a service order, acceptable index values are 1-5.
     * 
     * @param serviceOrderNumber 
     * @param resolutionIndex 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersDeleteServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResolutionResponse>;
    public serviceOrdersDeleteServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersDeleteServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersDeleteServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersDeleteServiceOrderResolution.');
        }
        if (resolutionIndex === null || resolutionIndex === undefined) {
            throw new Error('Required parameter resolutionIndex was null or undefined when calling serviceOrdersDeleteServiceOrderResolution.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<TsiWebServiceOrderResolutionResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/resolutions/${encodeURIComponent(String(resolutionIndex))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a symptom on a service order, acceptable index values are 1-5.
     * 
     * @param serviceOrderNumber 
     * @param symptomIndex 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersDeleteServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderSymptomResponse>;
    public serviceOrdersDeleteServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersDeleteServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersDeleteServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersDeleteServiceOrderSymptom.');
        }
        if (symptomIndex === null || symptomIndex === undefined) {
            throw new Error('Required parameter symptomIndex was null or undefined when calling serviceOrdersDeleteServiceOrderSymptom.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<TsiWebServiceOrderSymptomResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/symptoms/${encodeURIComponent(String(symptomIndex))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Advanced search for service orders.
     * Valid SearchType &#x3D; Technician, ExpenseType, ExpensePaymentType, Reimbursable, FromExpenseDate, ToExpenseDate, AcceptanceStatus.  &lt;p&gt;Valid MatchTypes for ExpenseType, ExpensePaymentType, Reimbursable, and AcceptanceStatus &#x3D; Equal. &lt;/p&gt;&lt;p&gt;Valid MatchTypes for FromExpenseDate, ToExpenseDate &#x3D; GreaterThan, GreaterThanEqual, Equal, LessThan, LessThanEqual. &lt;/p&gt;&lt;p&gt;Valid MatchTypes for Technician is StartsWith, EndsWith, Contains,&lt;/p&gt;&lt;p&gt;Valid Criteria for AcceptanceStatus &#x3D; Open, Accepted, Questioned, Resubmitted.&lt;/p&gt;&lt;p&gt;Valid Criteria for Reimbursable &#x3D; true or false.&lt;/p&gt;&lt;p&gt;Will return expenses only on service orders the rep has access to.&lt;/p&gt;
     * @param request An AdvancedSearchRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersExpenseAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpenseSearchResponse>;
    public serviceOrdersExpenseAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersExpenseAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersExpenseAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling serviceOrdersExpenseAdvancedSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpenseSearchResponse>(`${this.basePath}/api/serviceorders/expenses/search`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the recurring service order schedules for an account.
     * 
     * @param accountNumber The account number.
     * @param excludeCompleted Optional, return completed recurring service orders schedules.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetAccountRecurringServiceOrderSchedules(accountNumber: number, excludeCompleted: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebRecurringServiceOrderSchedulesResponse>;
    public serviceOrdersGetAccountRecurringServiceOrderSchedules(accountNumber: number, excludeCompleted: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebRecurringServiceOrderSchedulesResponse>>;
    public serviceOrdersGetAccountRecurringServiceOrderSchedules(accountNumber: number, excludeCompleted: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebRecurringServiceOrderSchedulesResponse>>;
    public serviceOrdersGetAccountRecurringServiceOrderSchedules(accountNumber: number, excludeCompleted: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountNumber === null || accountNumber === undefined) {
            throw new Error('Required parameter accountNumber was null or undefined when calling serviceOrdersGetAccountRecurringServiceOrderSchedules.');
        }
        if (excludeCompleted === null || excludeCompleted === undefined) {
            throw new Error('Required parameter excludeCompleted was null or undefined when calling serviceOrdersGetAccountRecurringServiceOrderSchedules.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebRecurringServiceOrderSchedulesResponse>(`${this.basePath}/api/serviceorders/recurringSchedule/account/${encodeURIComponent(String(accountNumber))}/${encodeURIComponent(String(excludeCompleted))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the account service orders.
     * Voided Service Orders are excluded by default.
     * @param accountNumber The account number.
     * @param excludeVoided Optional, return voided service orders
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetAccountServiceOrders(accountNumber: number, excludeVoided?: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersGetAccountServiceOrders(accountNumber: number, excludeVoided?: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersGetAccountServiceOrders(accountNumber: number, excludeVoided?: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersGetAccountServiceOrders(accountNumber: number, excludeVoided?: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountNumber === null || accountNumber === undefined) {
            throw new Error('Required parameter accountNumber was null or undefined when calling serviceOrdersGetAccountServiceOrders.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (excludeVoided !== undefined) {
            queryParameters = queryParameters.set('excludeVoided', <any>excludeVoided);
        }
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/account/${encodeURIComponent(String(accountNumber))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the account service orders.
     * Voided Service Orders are excluded by default.
     * @param accountNumber The account number.
     * @param excludeVoided Optional, return voided service orders
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetAccountServiceOrders_1(accountNumber: number, excludeVoided: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersGetAccountServiceOrders_1(accountNumber: number, excludeVoided: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersGetAccountServiceOrders_1(accountNumber: number, excludeVoided: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersGetAccountServiceOrders_1(accountNumber: number, excludeVoided: boolean, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (accountNumber === null || accountNumber === undefined) {
            throw new Error('Required parameter accountNumber was null or undefined when calling serviceOrdersGetAccountServiceOrders_1.');
        }
        if (excludeVoided === null || excludeVoided === undefined) {
            throw new Error('Required parameter excludeVoided was null or undefined when calling serviceOrdersGetAccountServiceOrders_1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/account/${encodeURIComponent(String(accountNumber))}/${encodeURIComponent(String(excludeVoided))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the custom fields for the account.
     * 
     * @param serviceOrderNumber The account number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetCustomFields(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebCustomField>>;
    public serviceOrdersGetCustomFields(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebCustomField>>>;
    public serviceOrdersGetCustomFields(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebCustomField>>>;
    public serviceOrdersGetCustomFields(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetCustomFields.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebCustomField>>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/customfields`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a single recurring service order schedule.
     * 
     * @param recurringServiceOrderScheduleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetRecurringServiceOrderSchedule(recurringServiceOrderScheduleId: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebRecurringServiceOrderSchedule>;
    public serviceOrdersGetRecurringServiceOrderSchedule(recurringServiceOrderScheduleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebRecurringServiceOrderSchedule>>;
    public serviceOrdersGetRecurringServiceOrderSchedule(recurringServiceOrderScheduleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebRecurringServiceOrderSchedule>>;
    public serviceOrdersGetRecurringServiceOrderSchedule(recurringServiceOrderScheduleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (recurringServiceOrderScheduleId === null || recurringServiceOrderScheduleId === undefined) {
            throw new Error('Required parameter recurringServiceOrderScheduleId was null or undefined when calling serviceOrdersGetRecurringServiceOrderSchedule.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebRecurringServiceOrderSchedule>(`${this.basePath}/api/serviceorders/recurringSchedule/${encodeURIComponent(String(recurringServiceOrderScheduleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order assigned technicians.
     * 
     * @param serviceOrderNumber The service order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderAssignedTechs(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebServiceOrderAssignedTech>>;
    public serviceOrdersGetServiceOrderAssignedTechs(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebServiceOrderAssignedTech>>>;
    public serviceOrdersGetServiceOrderAssignedTechs(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebServiceOrderAssignedTech>>>;
    public serviceOrdersGetServiceOrderAssignedTechs(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderAssignedTechs.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebServiceOrderAssignedTech>>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/assignedtechs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order details by external ticket identifier.
     * 
     * @param externalTicketId The external ticket identifier.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderByExternalTicket(externalTicketId: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderDetail>;
    public serviceOrdersGetServiceOrderByExternalTicket(externalTicketId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderDetail>>;
    public serviceOrdersGetServiceOrderByExternalTicket(externalTicketId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderDetail>>;
    public serviceOrdersGetServiceOrderByExternalTicket(externalTicketId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (externalTicketId === null || externalTicketId === undefined) {
            throw new Error('Required parameter externalTicketId was null or undefined when calling serviceOrdersGetServiceOrderByExternalTicket.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (externalTicketId !== undefined) {
            queryParameters = queryParameters.set('externalTicketId', <any>externalTicketId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderDetail>(`${this.basePath}/api/serviceorders/externalticket`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order completed tasks.
     * If you are retrieving a private task and if you are not the owner, only the following the fields are retrieved.  &lt;p&gt;  AccountNumber, AccountName, ScheduledForRepNumber, ScheduledForRepName, StartDate, StartTime, WholeStartDateTime, EndDate, EndTime, WholeEnddateTime, IsPrivate  &lt;/p&gt;
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderCompletedTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebTasksResponse>;
    public serviceOrdersGetServiceOrderCompletedTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderCompletedTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderCompletedTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderCompletedTasks.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebTasksResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/tasks/completed`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order details.
     * DateTimeRequested has been deprecated please use DateRequested and TimeRequested instead.
     * @param serviceOrderNumber The service order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderDetail(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderDetail>;
    public serviceOrdersGetServiceOrderDetail(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderDetail>>;
    public serviceOrdersGetServiceOrderDetail(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderDetail>>;
    public serviceOrdersGetServiceOrderDetail(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        let url = `${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/details`;

        console.log('url: ', url);

        headers = this.configuration.setAuthHeaders(
            headers,
            "get", // httpMethod
            url,    // uri
            );

        return this.httpClient.get<TsiWebServiceOrderDetail>(            
            url,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a single service orde expense
     * 
     * @param serviceOrderNumber 
     * @param serviceOrderExpenseNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderExpense(serviceOrderNumber: number, serviceOrderExpenseNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpense>;
    public serviceOrdersGetServiceOrderExpense(serviceOrderNumber: number, serviceOrderExpenseNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpense>>;
    public serviceOrdersGetServiceOrderExpense(serviceOrderNumber: number, serviceOrderExpenseNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpense>>;
    public serviceOrdersGetServiceOrderExpense(serviceOrderNumber: number, serviceOrderExpenseNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderExpense.');
        }
        if (serviceOrderExpenseNumber === null || serviceOrderExpenseNumber === undefined) {
            throw new Error('Required parameter serviceOrderExpenseNumber was null or undefined when calling serviceOrdersGetServiceOrderExpense.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderExpense>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/expenses/${encodeURIComponent(String(serviceOrderExpenseNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order expenses.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderExpenses(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebServiceOrderExpense>>;
    public serviceOrdersGetServiceOrderExpenses(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebServiceOrderExpense>>>;
    public serviceOrdersGetServiceOrderExpenses(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebServiceOrderExpense>>>;
    public serviceOrdersGetServiceOrderExpenses(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderExpenses.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebServiceOrderExpense>>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/expenses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order incomplete tasks.
     * If you are retrieving a private task and if you are not the owner, only the following the fields are retrieved.  &lt;p&gt;  AccountNumber, AccountName, ScheduledForRepNumber, ScheduledForRepName, StartDate, StartTime, WholeStartDateTime, EndDate, EndTime, WholeEnddateTime, IsPrivate  &lt;/p&gt;
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderIncompleteTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebTasksResponse>;
    public serviceOrdersGetServiceOrderIncompleteTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderIncompleteTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderIncompleteTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderIncompleteTasks.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebTasksResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/tasks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param serviceOrderNumber 
     * @param itemServicedNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderItemServicedResponse>;
    public serviceOrdersGetServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersGetServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersGetServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderItemServiced.');
        }
        if (itemServicedNumber === null || itemServicedNumber === undefined) {
            throw new Error('Required parameter itemServicedNumber was null or undefined when calling serviceOrdersGetServiceOrderItemServiced.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderItemServicedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/itemsserviced/${encodeURIComponent(String(itemServicedNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order items serviced.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderItemsServiced(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderItemsServicedResponse>;
    public serviceOrdersGetServiceOrderItemsServiced(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderItemsServicedResponse>>;
    public serviceOrdersGetServiceOrderItemsServiced(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderItemsServicedResponse>>;
    public serviceOrdersGetServiceOrderItemsServiced(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderItemsServiced.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderItemsServicedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/itemsserviced`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order notes.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderNotes(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderNotesResponse>;
    public serviceOrdersGetServiceOrderNotes(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderNotesResponse>>;
    public serviceOrdersGetServiceOrderNotes(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderNotesResponse>>;
    public serviceOrdersGetServiceOrderNotes(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderNotes.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderNotesResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/notes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order parts used.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderParts(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersGetServiceOrderParts(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersGetServiceOrderParts(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersGetServiceOrderParts(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderParts.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderPartsUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the Service order profiles.
     * 
     * @param serviceOrderNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderProfiles(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebAssignedMarketingProfilesResponse>;
    public serviceOrdersGetServiceOrderProfiles(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebAssignedMarketingProfilesResponse>>;
    public serviceOrdersGetServiceOrderProfiles(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebAssignedMarketingProfilesResponse>>;
    public serviceOrdersGetServiceOrderProfiles(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderProfiles.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebAssignedMarketingProfilesResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/profiles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order quotes.
     * 
     * @param serviceOrderNumber The service order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderQuotes(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebServiceOrderQuote>>;
    public serviceOrdersGetServiceOrderQuotes(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebServiceOrderQuote>>>;
    public serviceOrdersGetServiceOrderQuotes(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebServiceOrderQuote>>>;
    public serviceOrdersGetServiceOrderQuotes(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderQuotes.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebServiceOrderQuote>>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/quotes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order subcontractors.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderSubContractors(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderSubContractorsResponse>;
    public serviceOrdersGetServiceOrderSubContractors(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderSubContractorsResponse>>;
    public serviceOrdersGetServiceOrderSubContractors(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderSubContractorsResponse>>;
    public serviceOrdersGetServiceOrderSubContractors(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderSubContractors.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderSubContractorsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/subContractors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order summary.
     * DateTimeRequested has been deprecated please use DateRequested and TimeRequested instead.
     * @param serviceOrderNumber The service order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderSummary(serviceOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderSummary>;
    public serviceOrdersGetServiceOrderSummary(serviceOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderSummary>>;
    public serviceOrdersGetServiceOrderSummary(serviceOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderSummary>>;
    public serviceOrdersGetServiceOrderSummary(serviceOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderSummary.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderSummary>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order tasks. Includes both completed and incomplete tasks.
     * If you are retrieving a private task and if you are not the owner, only the following the fields are retrieved.  &lt;p&gt;  AccountNumber, AccountName, ScheduledForRepNumber, ScheduledForRepName, StartDate, StartTime, WholeStartDateTime, EndDate, EndTime, WholeEnddateTime, IsPrivate  &lt;/p&gt;
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebTasksResponse>;
    public serviceOrdersGetServiceOrderTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebTasksResponse>>;
    public serviceOrdersGetServiceOrderTasks(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderTasks.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebTasksResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/tasks/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order time logs.
     * 
     * @param serviceOrderNumber The service order number.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderTimeLogs(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderTimeLogsResponse>;
    public serviceOrdersGetServiceOrderTimeLogs(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderTimeLogsResponse>>;
    public serviceOrdersGetServiceOrderTimeLogs(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderTimeLogsResponse>>;
    public serviceOrdersGetServiceOrderTimeLogs(serviceOrderNumber: number, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderTimeLogs.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderTimeLogsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/timelogs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the service order time logs based on the log ID.
     * 
     * @param serviceOrderNumber The service order number.
     * @param timeLogNumber service order time log ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersGetServiceOrderTimeLogsByLogNumber(serviceOrderNumber: number, timeLogNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderTimeLogsResponse>;
    public serviceOrdersGetServiceOrderTimeLogsByLogNumber(serviceOrderNumber: number, timeLogNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderTimeLogsResponse>>;
    public serviceOrdersGetServiceOrderTimeLogsByLogNumber(serviceOrderNumber: number, timeLogNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderTimeLogsResponse>>;
    public serviceOrdersGetServiceOrderTimeLogsByLogNumber(serviceOrderNumber: number, timeLogNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersGetServiceOrderTimeLogsByLogNumber.');
        }
        if (timeLogNumber === null || timeLogNumber === undefined) {
            throw new Error('Required parameter timeLogNumber was null or undefined when calling serviceOrdersGetServiceOrderTimeLogsByLogNumber.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebServiceOrderTimeLogsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/timelogs/${encodeURIComponent(String(timeLogNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using an agreement number.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByAgreementNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByAgreementNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByAgreementNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByAgreementNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByAgreementNumber.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/agreementnumber`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Service Orders using a custom category and field label.
     * 
     * @param model A {Tsi.Web.CustomFieldSearchModel}
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByCustomField(model: TsiWebCustomFieldSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByCustomField(model: TsiWebCustomFieldSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByCustomField(model: TsiWebCustomFieldSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByCustomField(model: TsiWebCustomFieldSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersSearchByCustomField.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/customfield`,
            model,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using customer purchase order.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByCustomerPurchaseOrder(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByCustomerPurchaseOrder(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByCustomerPurchaseOrder(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByCustomerPurchaseOrder(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByCustomerPurchaseOrder.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/customerpurchaseorder`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using an external product name.
     * 
     * @param criteria An external product name, full name required.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByExternalProduct(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByExternalProduct(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByExternalProduct(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByExternalProduct(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByExternalProduct.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/externalproduct`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using invoice number.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByInvoiceNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByInvoiceNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByInvoiceNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByInvoiceNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByInvoiceNumber.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/invoicenumber`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using items serviced.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByItemServiced(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByItemServiced(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByItemServiced(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByItemServiced(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByItemServiced.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/itemid`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using reference value.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByReference(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByReference(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByReference(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByReference(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByReference.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/reference`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search service orders using service order number.
     * 
     * @param criteria A JSON or XML string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchByServiceOrderNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchServiceOrderResponse>;
    public serviceOrdersSearchByServiceOrderNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByServiceOrderNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchServiceOrderResponse>>;
    public serviceOrdersSearchByServiceOrderNumber(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchByServiceOrderNumber.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchServiceOrderResponse>(`${this.basePath}/api/serviceorders/search/serviceordernumber`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search expenses using an acceptanc estatus.
     * Valid criteria is an integer to specify the rep requested.
     * @param criteria A string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchExpenseByAcceptanceStatus(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpenseSearchResponse>;
    public serviceOrdersSearchExpenseByAcceptanceStatus(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByAcceptanceStatus(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByAcceptanceStatus(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchExpenseByAcceptanceStatus.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpenseSearchResponse>(`${this.basePath}/api/serviceorders/expenses/search/acceptancestatus`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search expenses using an expense date.
     * Valid criteria is a date.  &lt;p&gt;Valid MatchTypes are GreaterThan, GreaterThanEqual, Equal, LessThan, LessThanEqual. &lt;/p&gt;
     * @param model 
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchExpenseByExpenseDate(model: TsiWebDateTimeSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpenseSearchResponse>;
    public serviceOrdersSearchExpenseByExpenseDate(model: TsiWebDateTimeSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByExpenseDate(model: TsiWebDateTimeSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByExpenseDate(model: TsiWebDateTimeSearchModel, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersSearchExpenseByExpenseDate.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpenseSearchResponse>(`${this.basePath}/api/serviceorders/expenses/search/expensedate`,
            model,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search expenses using an expense type.
     * Valid criteria is a string with the expense type description or an integer expense type number.
     * @param criteria A string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchExpenseByExpenseType(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpenseSearchResponse>;
    public serviceOrdersSearchExpenseByExpenseType(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByExpenseType(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByExpenseType(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchExpenseByExpenseType.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpenseSearchResponse>(`${this.basePath}/api/serviceorders/expenses/search/expensetype`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search expenses using a technician name.
     * 
     * @param criteria A string containing the criteria.
     * @param pageRequestPageSize 
     * @param pageRequestStartRow 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSearchExpenseByTechnician(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpenseSearchResponse>;
    public serviceOrdersSearchExpenseByTechnician(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByTechnician(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpenseSearchResponse>>;
    public serviceOrdersSearchExpenseByTechnician(criteria: string, pageRequestPageSize?: number, pageRequestStartRow?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (criteria === null || criteria === undefined) {
            throw new Error('Required parameter criteria was null or undefined when calling serviceOrdersSearchExpenseByTechnician.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRequestPageSize !== undefined) {
            queryParameters = queryParameters.set('pageRequest.pageSize', <any>pageRequestPageSize);
        }
        if (pageRequestStartRow !== undefined) {
            queryParameters = queryParameters.set('pageRequest.startRow', <any>pageRequestStartRow);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebServiceOrderExpenseSearchResponse>(`${this.basePath}/api/serviceorders/expenses/search/technician`,
            criteria,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assigns a profile to a service order.
     * 
     * @param serviceOrderNumber The service order number.
     * @param profile The profile to assign.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersSetServiceOrderProfile(serviceOrderNumber: number, profile: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebAssignedMarketingProfilesResponse>;
    public serviceOrdersSetServiceOrderProfile(serviceOrderNumber: number, profile: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebAssignedMarketingProfilesResponse>>;
    public serviceOrdersSetServiceOrderProfile(serviceOrderNumber: number, profile: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebAssignedMarketingProfilesResponse>>;
    public serviceOrdersSetServiceOrderProfile(serviceOrderNumber: number, profile: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersSetServiceOrderProfile.');
        }
        if (profile === null || profile === undefined) {
            throw new Error('Required parameter profile was null or undefined when calling serviceOrdersSetServiceOrderProfile.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebAssignedMarketingProfilesResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/profiles`,
            profile,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Advanced search for service orders time logs.
     * Valid SearchType &#x3D; TimeLogNumber,TechAssigned, LogReason,StartDate,EndDate.
     * @param request An AdvancedSearchRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersTimeLogAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'body', reportProgress?: boolean): Observable<TsiWebSearchTimeLogResponse>;
    public serviceOrdersTimeLogAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebSearchTimeLogResponse>>;
    public serviceOrdersTimeLogAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebSearchTimeLogResponse>>;
    public serviceOrdersTimeLogAdvancedSearch(request: TsiWebAdvancedSearchRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling serviceOrdersTimeLogAdvancedSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebSearchTimeLogResponse>(`${this.basePath}/api/serviceorders/timelogs/search`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates account custom fields.
     * 
     * @param serviceOrderNumber The account number.
     * @param customFields The custom fields.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateCustomFields(serviceOrderNumber: number, customFields: Array<TsiWebCustomField>, observe?: 'body', reportProgress?: boolean): Observable<TsiWebCustomFieldsResponse>;
    public serviceOrdersUpdateCustomFields(serviceOrderNumber: number, customFields: Array<TsiWebCustomField>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebCustomFieldsResponse>>;
    public serviceOrdersUpdateCustomFields(serviceOrderNumber: number, customFields: Array<TsiWebCustomField>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebCustomFieldsResponse>>;
    public serviceOrdersUpdateCustomFields(serviceOrderNumber: number, customFields: Array<TsiWebCustomField>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateCustomFields.');
        }
        if (customFields === null || customFields === undefined) {
            throw new Error('Required parameter customFields was null or undefined when calling serviceOrdersUpdateCustomFields.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebCustomFieldsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/customfields`,
            customFields,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an expense.
     * The DistanceType field accepts values \&quot;DoNotChangeDistance\&quot;, \&quot;SetByEndOdometer\&quot;, or \&quot;SetByDistance\&quot;.      &lt;p&gt;The AcceptanceStatus field accepts values \&quot;Open\&quot;, \&quot;Accepted\&quot;, \&quot;Questioned\&quot;, or \&quot;Resubmitted\&quot;.&lt;/p&gt;
     * @param serviceOrderNumber 
     * @param expenseNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateExpense(serviceOrderNumber: number, expenseNumber: number, model: TsiWebUpdateExpenseModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderExpensesResponse>;
    public serviceOrdersUpdateExpense(serviceOrderNumber: number, expenseNumber: number, model: TsiWebUpdateExpenseModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderExpensesResponse>>;
    public serviceOrdersUpdateExpense(serviceOrderNumber: number, expenseNumber: number, model: TsiWebUpdateExpenseModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderExpensesResponse>>;
    public serviceOrdersUpdateExpense(serviceOrderNumber: number, expenseNumber: number, model: TsiWebUpdateExpenseModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateExpense.');
        }
        if (expenseNumber === null || expenseNumber === undefined) {
            throw new Error('Required parameter expenseNumber was null or undefined when calling serviceOrdersUpdateExpense.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateExpense.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderExpensesResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/expenses/${encodeURIComponent(String(expenseNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateManagedServiceOrder(model: TsiWebUpdateManagedServiceOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResponse>;
    public serviceOrdersUpdateManagedServiceOrder(model: TsiWebUpdateManagedServiceOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResponse>>;
    public serviceOrdersUpdateManagedServiceOrder(model: TsiWebUpdateManagedServiceOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResponse>>;
    public serviceOrdersUpdateManagedServiceOrder(model: TsiWebUpdateManagedServiceOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateManagedServiceOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderResponse>(`${this.basePath}/api/serviceorders/managed`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the service order.
     * DateTimeRequested is an optional SplitDateTime type. Json format is \&quot;DateTimeRequested\&quot;:{\&quot;Date\&quot;:\&quot;2018-03-06T00:00:00\&quot;, \&quot;Time\&quot;:\&quot;1900-01-01T14:09:02\&quot;}
     * @param serviceOrderNumber The service order number.
     * @param model The update service order model
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrder(serviceOrderNumber: number, model: TsiWebUpdateServiceOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResponse>;
    public serviceOrdersUpdateServiceOrder(serviceOrderNumber: number, model: TsiWebUpdateServiceOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResponse>>;
    public serviceOrdersUpdateServiceOrder(serviceOrderNumber: number, model: TsiWebUpdateServiceOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResponse>>;
    public serviceOrdersUpdateServiceOrder(serviceOrderNumber: number, model: TsiWebUpdateServiceOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrder.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the item serviced
     * The UpdateContractMetersType accepts values \&quot;DoNotUpdate\&quot;, \&quot;UpdateByReading\&quot;, or \&quot;UpdateByClicksUsed\&quot;.
     * @param serviceOrderNumber 
     * @param itemServicedNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, model: TsiWebUpdateServiceOrderItemServicedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderItemServicedResponse>;
    public serviceOrdersUpdateServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, model: TsiWebUpdateServiceOrderItemServicedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersUpdateServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, model: TsiWebUpdateServiceOrderItemServicedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderItemServicedResponse>>;
    public serviceOrdersUpdateServiceOrderItemServiced(serviceOrderNumber: number, itemServicedNumber: number, model: TsiWebUpdateServiceOrderItemServicedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderItemServiced.');
        }
        if (itemServicedNumber === null || itemServicedNumber === undefined) {
            throw new Error('Required parameter itemServicedNumber was null or undefined when calling serviceOrdersUpdateServiceOrderItemServiced.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderItemServiced.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderItemServicedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/ItemsServiced/${encodeURIComponent(String(itemServicedNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a non-stock part.
     * 
     * @param serviceOrderNumber The service order number.
     * @param partNumber The part number.
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderNonStockPartsUsedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersUpdateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderNonStockPartsUsedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersUpdateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderNonStockPartsUsedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersUpdateServiceOrderNonStockPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderNonStockPartsUsedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderNonStockPartsUsed.');
        }
        if (partNumber === null || partNumber === undefined) {
            throw new Error('Required parameter partNumber was null or undefined when calling serviceOrdersUpdateServiceOrderNonStockPartsUsed.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderNonStockPartsUsed.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderPartsUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/nonstock/${encodeURIComponent(String(partNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a service order note.
     * 
     * @param serviceOrderNumber 
     * @param serviceOrderNoteNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderNote(serviceOrderNumber: number, serviceOrderNoteNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderNoteResponse>;
    public serviceOrdersUpdateServiceOrderNote(serviceOrderNumber: number, serviceOrderNoteNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderNoteResponse>>;
    public serviceOrdersUpdateServiceOrderNote(serviceOrderNumber: number, serviceOrderNoteNumber: number, model: TsiWebServiceOrderNoteModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderNoteResponse>>;
    public serviceOrdersUpdateServiceOrderNote(serviceOrderNumber: number, serviceOrderNoteNumber: number, model: TsiWebServiceOrderNoteModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderNote.');
        }
        if (serviceOrderNoteNumber === null || serviceOrderNoteNumber === undefined) {
            throw new Error('Required parameter serviceOrderNoteNumber was null or undefined when calling serviceOrdersUpdateServiceOrderNote.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderNote.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderNoteResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/notes/${encodeURIComponent(String(serviceOrderNoteNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a part on a service order.
     * The UseBookPricesAndDiscounts field is required; if it is true then Price Levels will be used, if it is false then Sell Price will be used. To change the estimated cost UseBookPricesAndDiscounts must have a value.
     * @param serviceOrderNumber The service order number.
     * @param partNumber The part number.
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderPartsUsedModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartsUsedResponse>;
    public serviceOrdersUpdateServiceOrderPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderPartsUsedModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderPartsUsedModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartsUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsed(serviceOrderNumber: number, partNumber: number, model: TsiWebUpdateServiceOrderPartsUsedModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsed.');
        }
        if (partNumber === null || partNumber === undefined) {
            throw new Error('Required parameter partNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsed.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsed.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderPartsUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/${encodeURIComponent(String(partNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the assembly detail for a service order part
     * 
     * @param serviceOrderNumber 
     * @param partsUsedNumber 
     * @param partUsedAssemblyDetailNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail(serviceOrderNumber: number, partsUsedNumber: number, partUsedAssemblyDetailNumber: number, model: TsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartUsedResponse>;
    public serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail(serviceOrderNumber: number, partsUsedNumber: number, partUsedAssemblyDetailNumber: number, model: TsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail(serviceOrderNumber: number, partsUsedNumber: number, partUsedAssemblyDetailNumber: number, model: TsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail(serviceOrderNumber: number, partsUsedNumber: number, partUsedAssemblyDetailNumber: number, model: TsiWebUpdateServiceOrderPartsUsedAssemblyDetailModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail.');
        }
        if (partsUsedNumber === null || partsUsedNumber === undefined) {
            throw new Error('Required parameter partsUsedNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail.');
        }
        if (partUsedAssemblyDetailNumber === null || partUsedAssemblyDetailNumber === undefined) {
            throw new Error('Required parameter partUsedAssemblyDetailNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedAssemblyDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderPartUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/${encodeURIComponent(String(partsUsedNumber))}/assembly/${encodeURIComponent(String(partUsedAssemblyDetailNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a line item comment for the service order.
     * 
     * @param serviceOrderNumber 
     * @param partNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderPartsUsedComment(serviceOrderNumber: number, partNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderPartUsedResponse>;
    public serviceOrdersUpdateServiceOrderPartsUsedComment(serviceOrderNumber: number, partNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsedComment(serviceOrderNumber: number, partNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderPartUsedResponse>>;
    public serviceOrdersUpdateServiceOrderPartsUsedComment(serviceOrderNumber: number, partNumber: number, model: TsiWebServiceOrderPartsUsedCommentModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedComment.');
        }
        if (partNumber === null || partNumber === undefined) {
            throw new Error('Required parameter partNumber was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedComment.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderPartsUsedComment.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderPartUsedResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/parts/comments/${encodeURIComponent(String(partNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a resolution on a service order, acceptable values are 1-5
     * 
     * @param serviceOrderNumber 
     * @param resolutionIndex 
     * @param resolution 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, resolution: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderResolutionResponse>;
    public serviceOrdersUpdateServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, resolution: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersUpdateServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, resolution: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderResolutionResponse>>;
    public serviceOrdersUpdateServiceOrderResolution(serviceOrderNumber: number, resolutionIndex: number, resolution: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderResolution.');
        }
        if (resolutionIndex === null || resolutionIndex === undefined) {
            throw new Error('Required parameter resolutionIndex was null or undefined when calling serviceOrdersUpdateServiceOrderResolution.');
        }
        if (resolution === null || resolution === undefined) {
            throw new Error('Required parameter resolution was null or undefined when calling serviceOrdersUpdateServiceOrderResolution.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderResolutionResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/resolutions/${encodeURIComponent(String(resolutionIndex))}`,
            resolution,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a symptom on a service order, acceptable values are 1-5
     * 
     * @param serviceOrderNumber 
     * @param symptomIndex 
     * @param symptom 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, symptom: string, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderSymptomResponse>;
    public serviceOrdersUpdateServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, symptom: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersUpdateServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, symptom: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderSymptomResponse>>;
    public serviceOrdersUpdateServiceOrderSymptom(serviceOrderNumber: number, symptomIndex: number, symptom: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderSymptom.');
        }
        if (symptomIndex === null || symptomIndex === undefined) {
            throw new Error('Required parameter symptomIndex was null or undefined when calling serviceOrdersUpdateServiceOrderSymptom.');
        }
        if (symptom === null || symptom === undefined) {
            throw new Error('Required parameter symptom was null or undefined when calling serviceOrdersUpdateServiceOrderSymptom.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderSymptomResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/symptoms/${encodeURIComponent(String(symptomIndex))}`,
            symptom,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a service order time log.
     * Valid billing option types are - \&quot;InvoiceCustomer\&quot;, \&quot;ApplyToContract\&quot;, \&quot;ApplyToContractAndBillcustomer\&quot;, \&quot;DoNotInvoice\&quot;,   &lt;P&gt;  Valid rate basis values are - \&quot;Regular\&quot;, \&quot;Overtime\&quot;, \&quot;Premium\&quot;, \&quot;Standard\&quot;, \&quot;AccountDefault\&quot;, \&quot;PriceBook\&quot;, \&quot;FlatFee\&quot;, \&quot;Manual\&quot;.  &lt;/P&gt;&lt;P&gt;  Valid copy indicator type values are - \&quot;DoNotCopy,\&quot;CopyWhenSaving,\&quot;CopyWhenClosingLog\&quot;.  &lt;/P&gt;&lt;P&gt;  Valid time to invoice type values are - \&quot;BillableHoursMinutes\&quot;, \&quot;UtilizedTime\&quot;, \&quot;RoundedMinimunUtilizedtime\&quot;, \&quot;ActualTime\&quot;, \&quot;RoundedMinimunActualTime\&quot;.  &lt;/P&gt;&lt;P&gt;  Valid acceptance status type values are - \&quot;None\&quot;, \&quot;Accepted\&quot;, \&quot;Questioned\&quot;, \&quot;Resubmitted\&quot;,.  &lt;/P&gt;&lt;P&gt;  If the user does have \&quot;CanAdjustUtilizationHours\&quot; permission, the deductible hours and minutes will not be updated.  &lt;/P&gt;&lt;p&gt;  If the user does have \&quot;CanOverrideLaborRateOnTimeLogs\&quot; permissions, then logreason labor rate, rate basis and rate type will not be updated.  &lt;/p&gt;
     * @param serviceOrderNumber The service order number
     * @param timeLogNumber The time log number
     * @param model The update service order time log model.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public serviceOrdersUpdateServiceOrderTimeLog(serviceOrderNumber: number, timeLogNumber: number, model: TsiWebUpdateServiceOrderTimeLogModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebServiceOrderTimeLogResponse>;
    public serviceOrdersUpdateServiceOrderTimeLog(serviceOrderNumber: number, timeLogNumber: number, model: TsiWebUpdateServiceOrderTimeLogModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebServiceOrderTimeLogResponse>>;
    public serviceOrdersUpdateServiceOrderTimeLog(serviceOrderNumber: number, timeLogNumber: number, model: TsiWebUpdateServiceOrderTimeLogModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebServiceOrderTimeLogResponse>>;
    public serviceOrdersUpdateServiceOrderTimeLog(serviceOrderNumber: number, timeLogNumber: number, model: TsiWebUpdateServiceOrderTimeLogModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling serviceOrdersUpdateServiceOrderTimeLog.');
        }
        if (timeLogNumber === null || timeLogNumber === undefined) {
            throw new Error('Required parameter timeLogNumber was null or undefined when calling serviceOrdersUpdateServiceOrderTimeLog.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling serviceOrdersUpdateServiceOrderTimeLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebServiceOrderTimeLogResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/timelogs/${encodeURIComponent(String(timeLogNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
