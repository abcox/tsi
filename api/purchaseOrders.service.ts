/**
 * Tigerpaw API Method Reference
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 18.2.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { TsiWebCreatePurchaseOrderModel } from '../model/tsiWebCreatePurchaseOrderModel';
import { TsiWebCreatePurchaseOrderResponse } from '../model/tsiWebCreatePurchaseOrderResponse';
import { TsiWebPurchaseOrderDetail } from '../model/tsiWebPurchaseOrderDetail';
import { TsiWebPurchaseOrderLineItem } from '../model/tsiWebPurchaseOrderLineItem';
import { TsiWebPurchaseOrderLineItemReceipt } from '../model/tsiWebPurchaseOrderLineItemReceipt';
import { TsiWebPurchaseOrderLineItemSerialNumber } from '../model/tsiWebPurchaseOrderLineItemSerialNumber';
import { TsiWebPurchaseOrderResponse } from '../model/tsiWebPurchaseOrderResponse';
import { TsiWebPurchaseOrderSummary } from '../model/tsiWebPurchaseOrderSummary';
import { TsiWebPurchaseOrderVendorItemsResponse } from '../model/tsiWebPurchaseOrderVendorItemsResponse';
import { TsiWebUpdatePurchaseOrderModel } from '../model/tsiWebUpdatePurchaseOrderModel';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class PurchaseOrdersService {

    protected basePath = 'http://api2.tigerpawsoftware.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates a purchase order.
     * AssemblyCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost.&lt;br /&gt;  ShipToAddressType: Default,PrimaryAlternate, AccountNumber,None,AlternateAddressId.&lt;br /&gt;  BillToAddressType: Default,PrimaryAlternate, AccountNumber,None,AlternateAddressId.&lt;br /&gt;  UseVendorCostInPriceBook: if true the cost for pricebook items will be overriden if the vendor is configured with a cost on the price book item. Not applicable if CostToUseType &#x3D; OrderDetailEstimatedCost&lt;br /&gt;
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersCreatePurchaseOrder(model: TsiWebCreatePurchaseOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebCreatePurchaseOrderResponse>;
    public purchaseOrdersCreatePurchaseOrder(model: TsiWebCreatePurchaseOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebCreatePurchaseOrderResponse>>;
    public purchaseOrdersCreatePurchaseOrder(model: TsiWebCreatePurchaseOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebCreatePurchaseOrderResponse>>;
    public purchaseOrdersCreatePurchaseOrder(model: TsiWebCreatePurchaseOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling purchaseOrdersCreatePurchaseOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TsiWebCreatePurchaseOrderResponse>(`${this.basePath}/api/PurchaseOrders`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from service order using the price book item&#39;s lowest cost vendor.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param serviceOrderNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderLowestCostVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderLowestCostVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderLowestCostVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderLowestCostVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling purchaseOrdersGetCreateServiceOrderItemsWorkOrderLowestCostVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/purchaseorder/neededItems/lowestcostvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from service order using the price book item&#39;s lowest cost vendor.
     * A value is required for VendorAcountNumber.&lt;br /&gt;  purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;
     * @param serviceOrderNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOneVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOneVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOneVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOneVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling purchaseOrdersGetCreateServiceOrderItemsWorkOrderOneVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/purchaseorder/neededItems/onevendor`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from service orders using the item&#39;s primary vendor on the order.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param serviceOrderNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOrderPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOrderPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOrderPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderOrderPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling purchaseOrdersGetCreateServiceOrderItemsWorkOrderOrderPrimaryVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/purchaseorder/neededItems/orderprimaryvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from service order using the price book item&#39;s primary vendor.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param serviceOrderNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderPriceBookPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderPriceBookPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderPriceBookPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetCreateServiceOrderItemsWorkOrderPriceBookPrimaryVendor(serviceOrderNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (serviceOrderNumber === null || serviceOrderNumber === undefined) {
            throw new Error('Required parameter serviceOrderNumber was null or undefined when calling purchaseOrdersGetCreateServiceOrderItemsWorkOrderPriceBookPrimaryVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/serviceorders/${encodeURIComponent(String(serviceOrderNumber))}/purchaseorder/neededItems/pricebookprimaryvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the purchase order details.
     * 
     * @param purchaseOrderNumber The purchase order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderDetail(purchaseOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderDetail>;
    public purchaseOrdersGetPurchaseOrderDetail(purchaseOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderDetail>>;
    public purchaseOrdersGetPurchaseOrderDetail(purchaseOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderDetail>>;
    public purchaseOrdersGetPurchaseOrderDetail(purchaseOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderDetail>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}/details`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the receipts on the line items.
     * 
     * @param purchaseOrderNumber 
     * @param purchaseOrderLineItemNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderLineItemReciepts(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebPurchaseOrderLineItemReceipt>>;
    public purchaseOrdersGetPurchaseOrderLineItemReciepts(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebPurchaseOrderLineItemReceipt>>>;
    public purchaseOrdersGetPurchaseOrderLineItemReciepts(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebPurchaseOrderLineItemReceipt>>>;
    public purchaseOrdersGetPurchaseOrderLineItemReciepts(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderLineItemReciepts.');
        }
        if (purchaseOrderLineItemNumber === null || purchaseOrderLineItemNumber === undefined) {
            throw new Error('Required parameter purchaseOrderLineItemNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderLineItemReciepts.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebPurchaseOrderLineItemReceipt>>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}/items/${encodeURIComponent(String(purchaseOrderLineItemNumber))}/receipts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the serial numbers on the line item.
     * 
     * @param purchaseOrderNumber 
     * @param purchaseOrderLineItemNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderLineItemSerialNumbers(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebPurchaseOrderLineItemSerialNumber>>;
    public purchaseOrdersGetPurchaseOrderLineItemSerialNumbers(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebPurchaseOrderLineItemSerialNumber>>>;
    public purchaseOrdersGetPurchaseOrderLineItemSerialNumbers(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebPurchaseOrderLineItemSerialNumber>>>;
    public purchaseOrdersGetPurchaseOrderLineItemSerialNumbers(purchaseOrderNumber: number, purchaseOrderLineItemNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderLineItemSerialNumbers.');
        }
        if (purchaseOrderLineItemNumber === null || purchaseOrderLineItemNumber === undefined) {
            throw new Error('Required parameter purchaseOrderLineItemNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderLineItemSerialNumbers.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebPurchaseOrderLineItemSerialNumber>>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}/items/${encodeURIComponent(String(purchaseOrderLineItemNumber))}/serialnumbers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the line items on the purchase order.
     * 
     * @param purchaseOrderNumber 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderLineItems(purchaseOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TsiWebPurchaseOrderLineItem>>;
    public purchaseOrdersGetPurchaseOrderLineItems(purchaseOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TsiWebPurchaseOrderLineItem>>>;
    public purchaseOrdersGetPurchaseOrderLineItems(purchaseOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TsiWebPurchaseOrderLineItem>>>;
    public purchaseOrdersGetPurchaseOrderLineItems(purchaseOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderLineItems.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<TsiWebPurchaseOrderLineItem>>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}/items`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the purchase order summary.
     * 
     * @param purchaseOrderNumber The purchase order number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderSummary(purchaseOrderNumber: number, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderSummary>;
    public purchaseOrdersGetPurchaseOrderSummary(purchaseOrderNumber: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderSummary>>;
    public purchaseOrdersGetPurchaseOrderSummary(purchaseOrderNumber: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderSummary>>;
    public purchaseOrdersGetPurchaseOrderSummary(purchaseOrderNumber: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderSummary.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderSummary>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from work order using the price book item&#39;s lowest cost vendor.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param quoteNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderLowestCostVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderLowestCostVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderLowestCostVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderLowestCostVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (quoteNumber === null || quoteNumber === undefined) {
            throw new Error('Required parameter quoteNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderLowestCostVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/quotes/${encodeURIComponent(String(quoteNumber))}/purchaseorder/neededItems/lowestcostvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists work order using the price book item&#39;s lowest cost vendor.
     * A value is required for VendorAcountNumber.&lt;br /&gt;  purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;
     * @param quoteNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOneVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOneVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOneVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOneVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (quoteNumber === null || quoteNumber === undefined) {
            throw new Error('Required parameter quoteNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOneVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/quotes/${encodeURIComponent(String(quoteNumber))}/purchaseorder/neededItems/onevendor`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from work order using the item&#39;s primary vendor on the order.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param quoteNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOrderPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOrderPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOrderPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOrderPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (quoteNumber === null || quoteNumber === undefined) {
            throw new Error('Required parameter quoteNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderOrderPrimaryVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/quotes/${encodeURIComponent(String(quoteNumber))}/purchaseorder/neededItems/orderprimaryvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve vendor item lists from work order using the price book item&#39;s primary vendor.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  orderItemsInPhaseNumber: null for all phases, 0 for no phase, or the specific number for that phase.&lt;br /&gt;  orderVendorlessItems: if true a value is required for VendorAcountNumber.&lt;br /&gt;
     * @param quoteNumber 
     * @param purchaseOrderCostToUseType 
     * @param vendorAccountNumber 
     * @param orderItemsInPhaseNumber 
     * @param orderItemsInPhase 
     * @param orderLaborItems 
     * @param orderOnlyInsufficentItems 
     * @param orderVendorlessItems 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderPriceBookPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderVendorItemsResponse>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderPriceBookPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderPriceBookPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderVendorItemsResponse>>;
    public purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderPriceBookPrimaryVendor(quoteNumber: number, purchaseOrderCostToUseType?: string, vendorAccountNumber?: number, orderItemsInPhaseNumber?: number, orderItemsInPhase?: boolean, orderLaborItems?: boolean, orderOnlyInsufficentItems?: boolean, orderVendorlessItems?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (quoteNumber === null || quoteNumber === undefined) {
            throw new Error('Required parameter quoteNumber was null or undefined when calling purchaseOrdersGetPurchaseOrderVendorItemsWorkOrderPriceBookPrimaryVendor.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (purchaseOrderCostToUseType !== undefined) {
            queryParameters = queryParameters.set('purchaseOrderCostToUseType', <any>purchaseOrderCostToUseType);
        }
        if (vendorAccountNumber !== undefined) {
            queryParameters = queryParameters.set('vendorAccountNumber', <any>vendorAccountNumber);
        }
        if (orderItemsInPhaseNumber !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhaseNumber', <any>orderItemsInPhaseNumber);
        }
        if (orderItemsInPhase !== undefined) {
            queryParameters = queryParameters.set('orderItemsInPhase', <any>orderItemsInPhase);
        }
        if (orderLaborItems !== undefined) {
            queryParameters = queryParameters.set('orderLaborItems', <any>orderLaborItems);
        }
        if (orderOnlyInsufficentItems !== undefined) {
            queryParameters = queryParameters.set('orderOnlyInsufficentItems', <any>orderOnlyInsufficentItems);
        }
        if (orderVendorlessItems !== undefined) {
            queryParameters = queryParameters.set('orderVendorlessItems', <any>orderVendorlessItems);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<TsiWebPurchaseOrderVendorItemsResponse>(`${this.basePath}/api/quotes/${encodeURIComponent(String(quoteNumber))}/purchaseorder/neededItems/pricebookprimaryvendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a purchase order.
     * purchaseOrderCostToUseType : Base, Average, Latest, OrderDetailEstimatedCost -- the order item cost will only be used if \&quot;Use  this estimated cost when purchasing\&quot; is selected on the work/serivce order item, otherwise the base price will be used. &lt;br /&gt;  ShipToAddressType: Default,PrimaryAlternate, AccountNumber,None,AlternateAddressId.&lt;br /&gt;  BillToAddressType: Default,PrimaryAlternate, AccountNumber,None,AlternateAddressId.&lt;br /&gt;
     * @param purchaseOrderNumber 
     * @param model 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchaseOrdersUpdatePurchaseOrder(purchaseOrderNumber: number, model: TsiWebUpdatePurchaseOrderModel, observe?: 'body', reportProgress?: boolean): Observable<TsiWebPurchaseOrderResponse>;
    public purchaseOrdersUpdatePurchaseOrder(purchaseOrderNumber: number, model: TsiWebUpdatePurchaseOrderModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TsiWebPurchaseOrderResponse>>;
    public purchaseOrdersUpdatePurchaseOrder(purchaseOrderNumber: number, model: TsiWebUpdatePurchaseOrderModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TsiWebPurchaseOrderResponse>>;
    public purchaseOrdersUpdatePurchaseOrder(purchaseOrderNumber: number, model: TsiWebUpdatePurchaseOrderModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling purchaseOrdersUpdatePurchaseOrder.');
        }
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling purchaseOrdersUpdatePurchaseOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/x-www-form-urlencoded',
            'application/json',
            'application/xml',
            'text/xml'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<TsiWebPurchaseOrderResponse>(`${this.basePath}/api/purchaseorders/${encodeURIComponent(String(purchaseOrderNumber))}`,
            model,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
